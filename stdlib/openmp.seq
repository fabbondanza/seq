# OpenMP interface
# Ref: https://github.com/llvm/llvm-project/tree/main/openmp
Routine = Function[[i32, cobj], i32]

@tuple
class Ident:
    reserved_1: i32
    flags: i32
    reserved_2: i32
    reserved_3: i32
    psource: cobj

@tuple
class LRData:
    routine: Routine

@tuple
class Task:
    shareds: cobj
    routine: Routine
    flags: i32
    x: LRData
    y: LRData

@tuple
class TaskWithPrivates[T]:
    task: Task
    data: T

DEFAULT_SRC = ";unknown;unknown;0;0;;".ptr
DEFAULT_LOC = Ident(i32(0), i32(2), i32(0), i32(0), DEFAULT_SRC)

def default_loc():
    return __ptr__(DEFAULT_LOC)

@llvm
def bitcast[T](x) -> T:
    %y = bitcast {=typeof(x)} %x to {=T}
    ret {=T} %y

def single_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_single(Ptr[Ident], i32) -> i32
    return int(__kmpc_single(loc_ref, i32(gtid)))

def single_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_single(Ptr[Ident], i32)
    __kmpc_end_single(loc_ref, i32(gtid))

def task_alloc(loc_ref: Ptr[Ident], gtid: int, flags: int, size_of_task: int, size_of_shareds: int, task_entry: Routine):
    from C import __kmpc_omp_task_alloc(Ptr[Ident], i32, i32, int, int, Routine) -> cobj
    from internal.gc import add_roots
    task_handle = __kmpc_omp_task_alloc(loc_ref, i32(gtid), i32(flags), size_of_task, size_of_shareds, task_entry)
    base_offset = size_of_task - size_of_shareds
    add_roots(task_handle + base_offset, task_handle + size_of_task)
    return task_handle

def task_run(loc_ref: Ptr[Ident], gtid: int, new_task: cobj):
    from C import __kmpc_omp_task(Ptr[Ident], i32, cobj) -> i32
    return int(__kmpc_omp_task(loc_ref, i32(gtid), new_task))

def barrier(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_barrier(Ptr[Ident], i32)
    __kmpc_barrier(loc_ref, i32(gtid))

def static_init(loc_ref: Ptr[Ident], gtid: int, schedtype: int, loop: range, incr: int, chunk: int):
    from C import __kmpc_for_static_init_8(Ptr[Ident], i32, i32, Ptr[i32], Ptr[int], Ptr[int], Ptr[int], int, int)
    last = i32(0)
    lower = 0
    upper = len(loop) - 1
    stride = 1
    __kmpc_for_static_init_8(loc_ref, i32(gtid), i32(schedtype), __ptr__(last), __ptr__(lower), __ptr__(upper), __ptr__(stride), incr, chunk)
    return range(loop._get(lower), loop._get(upper + 1), loop.step)

def static_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_for_static_fini(Ptr[Ident], i32)
    __kmpc_for_static_fini(loc_ref, i32(gtid))

def fork_call(microtask: cobj, args):
    from C import __kmpc_fork_call(Ptr[Ident], i32, cobj, ...)
    loc_ref = default_loc()  # TODO: pass real loc?
    __kmpc_fork_call(loc_ref, i32(1), microtask, __ptr__(args))

def _static_loop_outline_template(gtid_ptr: Ptr[i32], data_ptr: Ptr[i32], args):
    def _static_loop_body_stub(i, args):
        pass

    start, stop, step, extra = args[0]
    gtid = int(gtid_ptr[0])
    loc_ref = default_loc()
    loop = range(start, stop, step)
    subloop = static_init(loc_ref, gtid, schedtype=34, loop=loop, incr=1, chunk=1)
    for i in subloop:
        _static_loop_body_stub(i, extra)
    static_fini(loc_ref, gtid)

# P = privates; tuple of types
# S = shareds; tuple of pointers
def _spawn_and_run_task[P,S](loc_ref: Ptr[Ident], gtid: int, routine: cobj, priv: P, shared: S):
    from internal.gc import sizeof

    TaskThunk = TaskWithPrivates[P]
    flags = 1
    size_of_kmp_task_t = sizeof[TaskThunk]()
    size_of_privs = sizeof[P]()
    size_of_shareds = sizeof[S]()
    loc_ref = default_loc()

    task = Ptr[TaskThunk](task_alloc(loc_ref, gtid, flags, size_of_kmp_task_t, size_of_shareds, Routine(routine)))
    if staticlen(shared) != 0:
        shared_ptr = task[0].task.shareds
        str.memcpy(shared_ptr, __ptr__(shared).as_byte(), size_of_shareds)
    if staticlen(priv) != 0:
        priv_ptr = task.as_byte() + sizeof[Task]()
        str.memcpy(priv_ptr, __ptr__(priv).as_byte(), size_of_privs)

    task_run(loc_ref, gtid, task.as_byte())

# Note: this is different than OpenMP's "taskloop" -- this template simply
# spawns a new task for each loop iteration.
def _task_loop_outline_template(gtid_ptr: Ptr[i32], data_ptr: Ptr[i32], args):
    def _routine_stub[P,S](gtid: i32, data: cobj):
        def _task_loop_body_stub(priv, shared):
            pass

        task = Ptr[TaskWithPrivates[P]](data)[0]
        priv = task.data
        if staticlen(S()) != 0:
            shared = Ptr[S](task.task.shareds)[0]
            _task_loop_body_stub(priv, shared)
        else:
            shared = ()
            _task_loop_body_stub(priv, shared)
        return i32(0)

    def _insert_new_loop_var(i, priv, shared):
        return priv, shared

    iterable, priv, shared = args[0]
    P = typeof(priv)
    S = typeof(shared)

    gtid = int(gtid_ptr[0])
    loc_ref = default_loc()

    if single_begin(loc_ref, gtid) != 0:
        try:
            for i in iterable:
                priv, shared = _insert_new_loop_var(i, priv, shared)
                _spawn_and_run_task(loc_ref, gtid, _routine_stub[P,S].__raw__(), priv, shared)
        finally:
            single_end(loc_ref, gtid)

    barrier(loc_ref, gtid)

